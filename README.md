# SMPR
Language R
# Метрические алгоритмы классификации
**Метрические методы обучения** -- методы, основанные на анализе сходства объектов.

Метрические алгоритмы классификации опираются на **_гипотезу компактности_**: схожим объектам соответствуют схожие ответы.

Метрические алгоритмы классификации с обучающей выборкой *Xl* относят объект *u* к тому классу *y*, для которого **суммарный вес ближайших обучающих объектов ![](https://latex.codecogs.com/gif.latex?W_y%28u%2C%20X%5El%29) максимален**:

![](https://latex.codecogs.com/gif.latex?W_y%28u%2C%20X%5El%29%20%3D%20%5Csum_%7Bi%20%3A%20y_%7Bu%7D%5E%7B%28i%29%7D%20%3D%20y%7D%20w%28i%2C%20u%29%20%5Crightarrow%20max)

, где весовая функция *w(i, u)* оценивает степень важности *i*-го соседа для классификации объекта *u*.

Функция ![](https://latex.codecogs.com/gif.latex?W_y%28u%2C%20X%5El%29) называется **_оценкой близости объекта u к классу y_**. Выбирая различную весовую функцию *w(i, u)* можно получать различные метрические классификаторы.

Лабораторная работа 1
Классификация ирисов Фишера методом 1NN (ближайшего соседа)

Решалась задача классификации. В качестве обучающей выборки была взята матрица ирисов фишера по длине и ширине лепестка.
Требовалось построить карту классификации на основе данных обучающей выборки.
В качестве метода классификации использовался метод 1NN.

# Суть метода 1NN: 
	1.Для классифицируемого объекта вычисляются расстояния от него до каждого объекта обучающей выборки.
	2.Обучающая выборка сортируется по возрастанию расстояния от каждого объекта выборки до классифицируемого
	3.Классифицируемому объекту присваивается тот же класс, что и ближайшего к нему объекта выборки.
  
  Лабораторная работа 2
Классификация ирисов Фишера методом kNN (k ближайших соседей)

Решалась задача классификации. В качестве обучающей выборки была взята матрица ирисов фишера по длине и ширине лепестка.
Требовалось построить карту классификации на основе данных обучающей выборки.
В качестве метода классификации использовался метод kNN.

# Метод kNN: 
	1.Для классифицируемого объекта вычисляются расстояния от него до каждого объекта обучающей выборки
	2.Обучающая выборка сортируется по возрастанию расстояния от каждого объекта выборки до классифицируемого
	3.Подсчитывается, какой класс доминирует среди k ближайших соседей, и этот класс присваивается классифицируемому объекту
	## Алгоритм k ближайших соседей (kNN)
Алгоритм 1NN относит классифицируемый объект U к тому классу, которому принадлежит его ближайший сосед.
ὠ(i,u)=[i=1];

Алгоритм kNN относит объект к тому классу, элементов которого больше среди k ближайших соседей x(i), i=1,..,k.

Для оценки близости классифицируемого объекта *u* к классу *y* **алгоритм kNN** использует следующую функцию:

ὠ(i,u)=[i<=k], где *i* -- порядок соседа по расстоянию к классифицируемому объекту *u*, k-количество параметровю=.
**Реализация весовой функции производится следующим образом**:

``` R
distances <- matrix(NA, l, 2) # расстояния от классифицируемого объекта u до каждого i-го соседа 
for(i in 1:l) {
   distances[i, ] <- c(i, eDist(xl[i, 1:n], u))
}
orderedxl <- xl[order(distances[ , 2]), ] # сортировка расстояний
classes <- orderedxl[1:k, n + 1] # названия первых k классов (k ближайших соседей) в classes 
```
### Преимущества:
1. Простота реализации.
2. При *k*, подобранном около оптимального, алгоритм "неплохо" классифицирует.

### Недостатки:
1. Нужно хранить всю выборку.
2. При *k = 1* неустойчивость к погрешностям (*выбросам* -- объектам, которые окружены объектами чужого класса), вследствие чего этот выброс классифицировался неверно и окружающие его объекты, для которого он окажется ближайшим, тоже.
2. При *k = l* алгоритм наоборот чрезмерно устойчив и вырождается в константу.
3. Крайне бедный набор параметров.
4. Точки, расстояние между которыми одинаково, не все будут учитываться.

	
Число k выбирается методом LOO (скользящего контроля)
# Метод LOO:
	1.Из обучающей выборки удаляется i-й объекта
	2.Запускается алгоритм классификации (в данном случае kNN) для полученной выборки и удалённого объекта
	3.Полученный класс объекта сравнивается с реальным. В случае несовпадения классов, величина ошибки увеличивается на 1
	4.Процесс повторяется для каждого объекта выборки
	5.Полученная ошибка усредняется
	6.Процесс повторяется для других значений k. В итоге выбирается число k с наименьшей ошибкой LOO
```	
##Составляем таблицу встречаемости каждого класса
counts <- table(classes)
class <- names(which.max(counts))
return (class)
}
## Метод скользящего контроля
LOO <- function(k,xl)
{
sum =0
for(i in 1:dim(xl)[1]{
tmpXL <- rbind(xl[1:i-1, ],
xl[i+1:dim(xl)[1],])
xi <- c(xl[i,1], xl[i,2])
class <-kNN(tmpXL,xi,k)
if(class != xl[i,3])
sum=sum+1
}
sum=sum/dim(xl)[1]
return(sum)
}
```
Для тестирования моделей в данной работе используется метод скользящего контроля. Метод скользящего контроля заключается в следующем. Исходная выборка делится на две подвыборки: обучающую и контрольную. По обучающей подвыборке происходит построение модели, после чего средняя ошибка модели оценивается с помощью контрольной подвыборки. Иными словами, по обучающей подвыборке строится модель, а затем с помощью данных из контрольной подвыборки проверяется, насколько верно данная модель способна предсказывать результат на новых данных, не использованных для ее построения. Существует несколько разновидностей скользящего контроля. Вследствие малого размера выборки во избежание ее дальнейшего уменьшения в данной работе используется контроль по отдельным объектам (leave-one-out CV). Данная разновидность метода скользящего контроля в качестве контрольной подвыборки использует одно наблюдение. То есть, если выборка состоит из N наблюдений, данный метод предполагает построение модели по N - 1 наблюдению и тестирование модели на оставшейся переменной. Такое перестроение модели повторяется N раз.
